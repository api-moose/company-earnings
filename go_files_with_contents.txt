File: ./cmd/app/main_test.go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/go-chi/chi/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	firebaseAuth "firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/middleware/access_control"
	auth "github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/api-moose/company-earnings/internal/utils/logging"
)

type MockFirebaseAuthClient struct {
	mock.Mock
}

func (m *MockFirebaseAuthClient) VerifyIDToken(ctx context.Context, idToken string) (*firebaseAuth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*firebaseAuth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestMain(m *testing.M) {
	err := os.Chdir("../..")
	if err != nil {
		log.Fatalf("Error changing directory: %v", err)
	}

	absPath, err := filepath.Abs(".env")
	if err != nil {
		log.Fatalf("Error getting absolute path: %v", err)
	}

	err = LoadEnv(absPath)
	if err != nil {
		log.Fatalf("Error loading .env file: %v", err)
	}

	code := m.Run()
	os.Exit(code)
}

func setupTestRouter() *chi.Mux {
	mockAuth := new(MockFirebaseAuthClient)
	validToken := &firebaseAuth.Token{
		UID: "valid_user",
		Claims: map[string]interface{}{
			"email":    "test@example.com",
			"tenantID": "tenant1",
			"role":     "user",
		},
	}
	mockAuth.On("VerifyIDToken", mock.Anything, "valid-token").Return(validToken, nil)
	mockAuth.On("VerifyIDToken", mock.Anything, "invalid-token").Return(nil, fmt.Errorf("invalid token"))

	r := chi.NewRouter()
	r.Use(logging.LoggingMiddleware)
	r.Use(tenancy.NewTenantMiddleware(mockAuth).Middleware)
	r.Use(auth.NewAuthMiddleware(mockAuth).Middleware)
	r.Use(access_control.RBACMiddleware)

	r.Get("/", mainHandler)
	r.Get("/health", healthCheckHandler)
	r.Get("/version", versionHandler)

	r.NotFound(func(w http.ResponseWriter, r *http.Request) {
		http.Error(w, "404 page not found", http.StatusNotFound)
	})

	return r
}

func TestSetupRouter(t *testing.T) {
	router := setupTestRouter()

	testCases := []struct {
		name           string
		path           string
		expectedStatus int
		expectedBody   interface{}
	}{
		{"Main route", "/", http.StatusOK, "Welcome to the Financial Data Platform API"},
		{"Health check route", "/health", http.StatusOK, map[string]string{"status": "healthy"}},
		{"Version route", "/version", http.StatusOK, map[string]string{"version": "0.1.0"}},
		{"Nonexistent route", "/nonexistent", http.StatusNotFound, "404 page not found"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req, err := http.NewRequest("GET", tc.path, nil)
			assert.NoError(t, err)

			req.Header.Set("Authorization", "Bearer valid-token")
			req.Header.Set("X-Tenant-ID", "tenant1")

			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			assert.Equal(t, tc.expectedStatus, rr.Code)

			if _, ok := tc.expectedBody.(string); ok {
				assert.Equal(t, tc.expectedBody, strings.TrimSpace(rr.Body.String()))
			} else {
				var actualBody map[string]string
				err = json.Unmarshal(rr.Body.Bytes(), &actualBody)
				assert.NoError(t, err)
				assert.Equal(t, tc.expectedBody, actualBody)
			}
		})
	}
}

func TestAuthMiddleware(t *testing.T) {
	router := setupTestRouter()

	testCases := []struct {
		name           string
		token          string
		expectedStatus int
	}{
		{"Valid token", "Bearer valid-token", http.StatusOK},
		{"Invalid token", "Bearer invalid-token", http.StatusUnauthorized},
		{"Missing token", "", http.StatusUnauthorized},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/", nil)
			if tc.token != "" {
				req.Header.Set("Authorization", tc.token)
			}
			req.Header.Set("X-Tenant-ID", "tenant1")

			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			assert.Equal(t, tc.expectedStatus, rr.Code)
		})
	}
}

func TestTenancyMiddleware(t *testing.T) {
	router := setupTestRouter()

	testCases := []struct {
		name           string
		tenantID       string
		expectedStatus int
	}{
		{"Valid tenant ID", "tenant1", http.StatusOK},
		{"Missing tenant ID", "", http.StatusBadRequest},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/", nil)
			req.Header.Set("Authorization", "Bearer valid-token")
			if tc.tenantID != "" {
				req.Header.Set("X-Tenant-ID", tc.tenantID)
			}

			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			assert.Equal(t, tc.expectedStatus, rr.Code)
		})
	}
}

func LoadEnv(filepath string) error {
	file, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer file.Close()

	content, err := io.ReadAll(file)
	if err != nil {
		return err
	}

	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])
		os.Setenv(key, value)
	}

	return nil
}
\n
File: ./cmd/app/main.go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"

	firebase "firebase.google.com/go/v4"
	firebaseAuth "firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/api/v1/company"
	"github.com/api-moose/company-earnings/internal/db/mongo"
	"github.com/api-moose/company-earnings/internal/middleware/access_control"
	auth "github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/api-moose/company-earnings/internal/utils/logging"
	"google.golang.org/api/option"
)

const version = "0.1.0"
const notFoundMessage = "404 page not found"

type FirebaseAuthWrapper struct {
	client *firebaseAuth.Client
}

func (f *FirebaseAuthWrapper) VerifyIDToken(ctx context.Context, idToken string) (*firebaseAuth.Token, error) {
	return f.client.VerifyIDToken(ctx, idToken)
}

func main() {
	// Set up logging
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.Println("Starting Financial Data Platform API")

	// Load Firebase credentials
	credentialsJSON := os.Getenv("FIREBASE_CREDENTIALS_FILE")
	if credentialsJSON == "" {
		log.Println("Warning: FIREBASE_CREDENTIALS_FILE environment variable is not set")
	}

	// Initialize Firebase app
	var app *firebase.App
	var err error
	if credentialsJSON != "" {
		opt := option.WithCredentialsJSON([]byte(credentialsJSON))
		app, err = firebase.NewApp(context.Background(), nil, opt)
		if err != nil {
			log.Printf("Error initializing Firebase app: %v", err)
			// Continue without Firebase for now
		}
	}

	var wrappedAuthClient *FirebaseAuthWrapper
	if app != nil {
		// Get Firebase Auth client
		authClient, err := app.Auth(context.Background())
		if err != nil {
			log.Printf("Error getting Firebase Auth client: %v", err)
			// Continue without Firebase Auth for now
		} else {
			wrappedAuthClient = &FirebaseAuthWrapper{client: authClient}
		}
	}

	// Set up router
	r := setupRouter(wrappedAuthClient)

	// Get port from environment variable
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
		log.Println("PORT not set, using default port 8080")
	}

	// Create server
	server := &http.Server{
		Addr:    ":" + port,
		Handler: r,
	}

	// Start server
	go func() {
		log.Printf("Server listening on port %s", port)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Server error: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shut down the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
	<-quit
	log.Println("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server exiting")
}

func setupRouter(authClient auth.FirebaseAuthClient) *chi.Mux {
	r := chi.NewRouter()

	r.Use(middleware.Recoverer)
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Logger)
	r.Use(logging.LoggingMiddleware)

	if authClient != nil {
		r.Use(tenancy.NewTenantMiddleware(authClient).Middleware)
		r.Use(auth.NewAuthMiddleware(authClient).Middleware)
		r.Use(access_control.RBACMiddleware)
	} else {
		log.Println("Warning: Running without authentication middleware")
	}

	r.Get("/", mainHandler)
	r.Get("/health", healthCheckHandler)
	r.Get("/version", versionHandler)

	// Add company search route
	companyRepo := mongo.NewRepository()
	companyHandler := company.NewHandler(companyRepo)
	r.Get("/api/v1/companies", companyHandler.SearchHandler)

	r.NotFound(notFoundHandler)

	return r
}

func notFoundHandler(w http.ResponseWriter, r *http.Request) {
	http.Error(w, notFoundMessage, http.StatusNotFound)
}

func mainHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Welcome to the Financial Data Platform API")
}

func healthCheckHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	response := map[string]string{"status": "healthy"}
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding health check response: %v", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	}
}

func versionHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	response := map[string]string{"version": version}
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding version response: %v", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	}
}
\n
File: ./internal/db/mongo/user_test.go
package mongo

import (
	"testing"
)

func TestNewUser(t *testing.T) {
	user := NewUser("1", "testuser", "test@example.com", "user", "tenant1")

	if user.ID != "1" {
		t.Errorf("Expected ID '1', got '%s'", user.ID)
	}
	if user.Username != "testuser" {
		t.Errorf("Expected Username 'testuser', got '%s'", user.Username)
	}
	if user.Email != "test@example.com" {
		t.Errorf("Expected Email 'test@example.com', got '%s'", user.Email)
	}
	if user.Role != "user" {
		t.Errorf("Expected Role 'user', got '%s'", user.Role)
	}
	if user.TenantID != "tenant1" {
		t.Errorf("Expected TenantID 'tenant1', got '%s'", user.TenantID)
	}
}

func TestUserValidate(t *testing.T) {
	tests := []struct {
		name    string
		user    *User
		wantErr bool
	}{
		{
			name:    "Valid user",
			user:    NewUser("1", "testuser", "test@example.com", "user", "tenant1"),
			wantErr: false,
		},
		{
			name:    "Missing ID",
			user:    NewUser("", "testuser", "test@example.com", "user", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing Username",
			user:    NewUser("1", "", "test@example.com", "user", "tenant1"),
			wantErr: false, // Username is not required in the current Validate method
		},
		{
			name:    "Missing Email",
			user:    NewUser("1", "testuser", "", "user", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing Role",
			user:    NewUser("1", "testuser", "test@example.com", "", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing TenantID",
			user:    NewUser("1", "testuser", "test@example.com", "user", ""),
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.user.Validate()
			if (err != nil) != tt.wantErr {
				t.Errorf("User.Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
\n
File: ./internal/db/mongo/company.go
// internal/db/mongo/company.go
package mongo

import (
	"context"
	"errors"

	"github.com/api-moose/company-earnings/internal/models"
)

type Repository interface {
	Search(ctx context.Context, query string, limit int) ([]models.Company, error)
}

type companyRepository struct{}

func NewRepository() Repository {
	return &companyRepository{}
}

func (r *companyRepository) Search(ctx context.Context, query string, limit int) ([]models.Company, error) {
	if query == "" {
		return nil, errors.New("query cannot be empty")
	}

	// TODO: Implement actual database search logic
	// For now, we'll return a mock result
	if query == "Apple" {
		return []models.Company{
			{
				Symbol:       "AAPL",
				CIK:          "0000320193",
				SecurityName: "Apple Inc.",
				SecurityType: "Common Stock",
				Region:       "US",
				Exchange:     "NASDAQ",
				Sector:       "Technology",
			},
		}, nil
	}

	return []models.Company{}, nil
}
\n
File: ./internal/db/mongo/user.go
package mongo

import "errors"

// User represents a user in the system
type User struct {
	ID       string
	Username string
	Email    string
	Role     string
	TenantID string
}

// NewUser creates a new User instance
func NewUser(id, username, email, role, tenantID string) *User {
	return &User{
		ID:       id,
		Username: username,
		Email:    email,
		Role:     role,
		TenantID: tenantID,
	}
}

// Validate checks if the user data is valid
func (u *User) Validate() error {
	if u.ID == "" {
		return errors.New("id is required")
	}
	if u.Email == "" {
		return errors.New("email is required")
	}
	if u.Role == "" {
		return errors.New("role is required")
	}
	if u.TenantID == "" {
		return errors.New("tenantID is required")
	}
	return nil
}
\n
File: ./internal/db/mongo/company_test.go
// internal/db/mongo/company_test.go
package mongo

import (
	"context"
	"testing"

	"github.com/api-moose/company-earnings/internal/models"
	"github.com/stretchr/testify/assert"
)

func TestCompanyRepository_Search(t *testing.T) {
	tests := []struct {
		name    string
		query   string
		limit   int
		want    []models.Company
		wantErr bool
	}{
		{
			name:  "Valid search",
			query: "Apple",
			limit: 1,
			want: []models.Company{
				{
					Symbol:       "AAPL",
					CIK:          "0000320193",
					SecurityName: "Apple Inc.",
					SecurityType: "Common Stock",
					Region:       "US",
					Exchange:     "NASDAQ",
					Sector:       "Technology",
				},
			},
			wantErr: false,
		},
		{
			name:    "Empty query",
			query:   "",
			limit:   10,
			want:    nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := NewRepository()
			got, err := r.Search(context.Background(), tt.query, tt.limit)
			if (err != nil) != tt.wantErr {
				t.Errorf("CompanyRepository.Search() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got)
		})
	}
}
\n
File: ./internal/config/config.go
package config

import (
	"context"
	"fmt"

	firebase "firebase.google.com/go"
	"google.golang.org/api/option"
)

type FirebaseApp struct {
	*firebase.App
}

func NewFirebaseApp(credentialFile string) (*FirebaseApp, error) {
	ctx := context.Background()
	opt := option.WithCredentialsFile(credentialFile)
	app, err := firebase.NewApp(ctx, nil, opt)
	if err != nil {
		return nil, fmt.Errorf("error initializing app: %v", err)
	}
	return &FirebaseApp{App: app}, nil
}
\n
File: ./internal/config/config_test.go
package config

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewFirebaseApp(t *testing.T) {
	app, err := NewFirebaseApp("path/to/serviceAccountKey.json")
	assert.NoError(t, err)
	assert.NotNil(t, app)
}
\n
File: ./internal/models/company.go
// internal/models/company.go
package models

type Company struct {
	Symbol       string `json:"symbol"`
	CIK          string `json:"cik"`
	SecurityName string `json:"securityName"`
	SecurityType string `json:"securityType"`
	Region       string `json:"region"`
	Exchange     string `json:"exchange"`
	Sector       string `json:"sector"`
}
\n
File: ./internal/api/v1/company/company_handler_test.go
// internal/api/v1/company/company_handler_test.go
package company

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/api-moose/company-earnings/internal/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockRepository struct {
	mock.Mock
}

func (m *MockRepository) Search(ctx context.Context, query string, limit int) ([]models.Company, error) {
	args := m.Called(ctx, query, limit)
	return args.Get(0).([]models.Company), args.Error(1)
}

func TestSearchHandler(t *testing.T) {
	tests := []struct {
		name           string
		query          string
		mockResult     []models.Company
		mockError      error
		expectedStatus int
		expectedBody   string
	}{
		{
			name:  "Valid search",
			query: "Apple",
			mockResult: []models.Company{
				{
					Symbol:       "AAPL",
					CIK:          "0000320193",
					SecurityName: "Apple Inc.",
					SecurityType: "Common Stock",
					Region:       "US",
					Exchange:     "NASDAQ",
					Sector:       "Technology",
				},
			},
			mockError:      nil,
			expectedStatus: http.StatusOK,
			expectedBody:   `{"count":1,"results":[{"symbol":"AAPL","cik":"0000320193","securityName":"Apple Inc.","securityType":"Common Stock","region":"US","exchange":"NASDAQ","sector":"Technology"}],"next_url":null}`,
		},
		{
			name:           "Empty query",
			query:          "",
			mockResult:     nil,
			mockError:      nil,
			expectedStatus: http.StatusBadRequest,
			expectedBody:   `{"error":"query cannot be empty"}`,
		},
		{
			name:           "Repository error",
			query:          "Error",
			mockResult:     nil,
			mockError:      errors.New("repository error"),
			expectedStatus: http.StatusInternalServerError,
			expectedBody:   `{"error":"repository error"}`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockRepository)
			if tt.query != "" {
				mockRepo.On("Search", mock.Anything, tt.query, 10).Return(tt.mockResult, tt.mockError)
			}

			handler := NewHandler(mockRepo)

			req, err := http.NewRequest("GET", "/companies?query="+tt.query, nil)
			assert.NoError(t, err)

			rr := httptest.NewRecorder()
			handler.SearchHandler(rr, req)

			assert.Equal(t, tt.expectedStatus, rr.Code)

			if tt.expectedStatus == http.StatusOK {
				var response map[string]interface{}
				err = json.Unmarshal(rr.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, float64(len(tt.mockResult)), response["count"])
				assert.Equal(t, tt.mockResult[0].Symbol, response["results"].([]interface{})[0].(map[string]interface{})["symbol"])
			} else {
				assert.JSONEq(t, tt.expectedBody, rr.Body.String())
			}

			mockRepo.AssertExpectations(t)
		})
	}
}
\n
File: ./internal/api/v1/company/company_handler.go
// internal/api/v1/company/company_handler.go
package company

import (
	"context"
	"net/http"
	"strconv"

	"github.com/api-moose/company-earnings/internal/db/mongo"
	"github.com/api-moose/company-earnings/internal/models"
	"github.com/api-moose/company-earnings/internal/utils/response"
)

type Handler struct {
	repo mongo.Repository
}

func NewHandler(repo mongo.Repository) *Handler {
	return &Handler{repo: repo}
}

func (h *Handler) SearchHandler(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query().Get("query")
	if query == "" {
		response.ErrorResponse(w, &response.ErrorMessage{
			Status:  http.StatusBadRequest,
			Message: "query cannot be empty",
		})
		return
	}

	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if limit == 0 {
		limit = 10 // Default limit
	}

	companies, err := h.search(r.Context(), query, limit)
	if err != nil {
		response.ErrorResponse(w, err)
		return
	}

	resp := struct {
		Count   int              `json:"count"`
		Results []models.Company `json:"results"`
		NextURL *string          `json:"next_url"`
	}{
		Count:   len(companies),
		Results: companies,
		NextURL: nil, // Implement pagination logic if needed
	}

	response.JSONResponse(w, http.StatusOK, resp)
}

func (h *Handler) search(ctx context.Context, query string, limit int) ([]models.Company, error) {
	return h.repo.Search(ctx, query, limit)
}
\n
File: ./internal/services/auth/auth_service_test.go
package auth

import (
	"context"
	"errors"
	"testing"

	"firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/db/mongo"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFirebaseClient struct {
	mock.Mock
}

func (m *MockFirebaseClient) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockFirebaseClient) GetUser(ctx context.Context, uid string) (*auth.UserRecord, error) {
	args := m.Called(ctx, uid)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.UserRecord), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestAuthService_AuthenticateUser(t *testing.T) {
	mockClient := new(MockFirebaseClient)
	validToken := &auth.Token{
		UID: "valid_user",
		Claims: map[string]interface{}{
			"role":     "admin",
			"tenantID": "tenant1",
		},
	}
	userRecord := &auth.UserRecord{
		UserInfo: &auth.UserInfo{
			UID:         "valid_user",
			Email:       "test@example.com",
			DisplayName: "Test User",
		},
	}

	mockClient.On("VerifyIDToken", mock.Anything, "valid_token").Return(validToken, nil)
	mockClient.On("VerifyIDToken", mock.Anything, "invalid_token").Return(nil, errors.New("invalid token"))
	mockClient.On("GetUser", mock.Anything, "valid_user").Return(userRecord, nil)

	authService := NewAuthService(mockClient)

	tests := []struct {
		name         string
		token        string
		expectedErr  error
		expectedUser *mongo.User
	}{
		{
			name:  "Valid token",
			token: "valid_token",
			expectedUser: &mongo.User{
				ID:       "valid_user",
				Username: "Test User",
				Email:    "test@example.com",
				Role:     "admin",
				TenantID: "tenant1",
			},
			expectedErr: nil,
		},
		{
			name:         "Invalid token",
			token:        "invalid_token",
			expectedUser: nil,
			expectedErr:  errors.New("invalid token"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			user, err := authService.AuthenticateUser(context.Background(), tt.token)
			assert.Equal(t, tt.expectedErr, err)
			assert.Equal(t, tt.expectedUser, user)
		})
	}

	mockClient.AssertExpectations(t)
}
\n
File: ./internal/services/auth/auth_service.go
package auth

import (
	"context"

	"firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/db/mongo"
)

type FirebaseAuthClient interface {
	VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error)
	GetUser(ctx context.Context, uid string) (*auth.UserRecord, error)
}

type AuthService struct {
	client FirebaseAuthClient
}

func NewAuthService(client FirebaseAuthClient) *AuthService {
	return &AuthService{client: client}
}

func (s *AuthService) AuthenticateUser(ctx context.Context, token string) (*mongo.User, error) {
	decodedToken, err := s.client.VerifyIDToken(ctx, token)
	if err != nil {
		return nil, err
	}

	firebaseUser, err := s.client.GetUser(ctx, decodedToken.UID)
	if err != nil {
		return nil, err
	}

	user := &mongo.User{
		ID:       firebaseUser.UID,
		Username: firebaseUser.DisplayName,
		Email:    firebaseUser.Email,
		Role:     getRoleFromClaims(decodedToken.Claims),
		TenantID: getTenantIDFromClaims(decodedToken.Claims),
	}

	return user, nil
}

func getRoleFromClaims(claims map[string]interface{}) string {
	if role, ok := claims["role"].(string); ok {
		return role
	}
	return "user" // Default role if not specified
}

func getTenantIDFromClaims(claims map[string]interface{}) string {
	if tenantID, ok := claims["tenantID"].(string); ok {
		return tenantID
	}
	return "" // Empty string if not specified
}
\n
File: ./internal/services/company/company_service.go
// internal/services/company/company_service.go
package company

import (
	"context"

	"github.com/api-moose/company-earnings/internal/db/mongo"
	"github.com/api-moose/company-earnings/internal/models"
)

type Service interface {
	Search(ctx context.Context, query string, limit int) ([]models.Company, error)
}

type companyService struct {
	repo mongo.Repository
}

func NewService(repo mongo.Repository) Service {
	return &companyService{repo: repo}
}

func (s *companyService) Search(ctx context.Context, query string, limit int) ([]models.Company, error) {
	return s.repo.Search(ctx, query, limit)
}
\n
File: ./internal/services/company/company_service_test.go
// internal/services/company/service_test.go
package company

import (
	"context"
	"testing"

	"github.com/api-moose/company-earnings/internal/models"
	"github.com/stretchr/testify/assert"
)

func TestCompanyService_Search(t *testing.T) {
	tests := []struct {
		name    string
		query   string
		limit   int
		want    []models.Company
		wantErr bool
	}{
		{
			name:  "Valid search",
			query: "Apple",
			limit: 1,
			want: []models.Company{
				{
					Symbol:       "AAPL",
					CIK:          "0000320193",
					SecurityName: "Apple Inc.",
					SecurityType: "Common Stock",
					Region:       "US",
					Exchange:     "NASDAQ",
					Sector:       "Technology",
				},
			},
			wantErr: false,
		},
		{
			name:    "Empty query",
			query:   "",
			limit:   10,
			want:    nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := NewService()
			got, err := s.Search(context.Background(), tt.query, tt.limit)
			if (err != nil) != tt.wantErr {
				t.Errorf("CompanyService.Search() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got)
		})
	}
}
\n
File: ./internal/utils/utils_test.go
package main

import (
	"net/http"
	"testing"
)

func TestAppError(t *testing.T) {
	err := NewAppError(http.StatusNotFound, "Resource not found")
	if err == nil {
		t.Error("Expected error, got nil")
	}
	if err.Error() != "Error 404: Resource not found" {
		t.Errorf("Unexpected error message: got %q", err.Error())
	}
}
\n
File: ./internal/utils/response/response.go
package response

import (
	"encoding/json"
	"net/http"

	"github.com/api-moose/company-earnings/internal/errors/httperrors"
)

func JSONResponse(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(data)
}

func ErrorResponse(w http.ResponseWriter, err error) {
	httpErr, ok := err.(*httperrors.HTTPError)
	if !ok {
		httpErr = httperrors.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")
	}

	JSONResponse(w, httpErr.StatusCode, map[string]string{"error": httpErr.Message})
}
\n
File: ./internal/utils/response/response_test.go
package response

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/api-moose/company-earnings/internal/errors/httperrors"
)

func TestJSONResponse(t *testing.T) {
	w := httptest.NewRecorder()
	data := map[string]string{"message": "success"}

	JSONResponse(w, http.StatusOK, data)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status code %d, got %d", http.StatusOK, w.Code)
	}

	var response map[string]string
	err := json.Unmarshal(w.Body.Bytes(), &response)
	if err != nil {
		t.Fatalf("Error unmarshaling response: %v", err)
	}

	if response["message"] != "success" {
		t.Errorf("Expected message 'success', got '%s'", response["message"])
	}
}

func TestErrorResponse(t *testing.T) {
	w := httptest.NewRecorder()
	err := httperrors.NewHTTPError(http.StatusBadRequest, "invalid input")

	ErrorResponse(w, err)

	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected status code %d, got %d", http.StatusBadRequest, w.Code)
	}

	var response map[string]string
	jsonErr := json.Unmarshal(w.Body.Bytes(), &response)
	if jsonErr != nil {
		t.Fatalf("Error unmarshaling response: %v", jsonErr)
	}

	if response["error"] != "invalid input" {
		t.Errorf("Expected error 'invalid input', got '%s'", response["error"])
	}
}
\n
File: ./internal/utils/logging/logging.go
package logging

import (
	"log"
	"net/http"
	"time"
)

func LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("Entering LoggingMiddleware")
		start := time.Now()

		// Wrap the response writer to capture the status code
		wrappedWriter := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

		// Call the next handler
		next.ServeHTTP(wrappedWriter, r)

		// Log the request details
		log.Printf(
			"Exiting LoggingMiddleware: %s %s %s %d %v",
			r.RemoteAddr,
			r.Method,
			r.URL.Path,
			wrappedWriter.statusCode,
			time.Since(start),
		)
	})
}

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}
\n
File: ./internal/utils/logging/logging_test.go
package logging

import (
	"bytes"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestLoggingMiddleware(t *testing.T) {
	// Create a buffer to capture log output
	var buf bytes.Buffer
	log.SetOutput(&buf)

	// Create a test handler
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// Wrap the test handler with the logging middleware
	handler := LoggingMiddleware(testHandler)

	// Create a test request
	req := httptest.NewRequest("GET", "/test", nil)
	req.RemoteAddr = "127.0.0.1:12345"

	// Create a response recorder
	rr := httptest.NewRecorder()

	// Serve the request using the wrapped handler
	handler.ServeHTTP(rr, req)

	// Check if the status code is still correct
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("handler returned wrong status code: got %v want %v",
			status, http.StatusOK)
	}

	// Check if the log output contains expected information
	logOutput := buf.String()
	expectedEntries := []string{
		"127.0.0.1:12345",
		"GET",
		"/test",
		"200",
	}

	for _, entry := range expectedEntries {
		if !strings.Contains(logOutput, entry) {
			t.Errorf("Log output missing expected entry: %s", entry)
		}
	}
}
\n
File: ./internal/utils/utils.go
package main

import "fmt"

// AppError represents an application-level error.
type AppError struct {
	StatusCode int
	Message    string
}

func (e *AppError) Error() string {
	return fmt.Sprintf("Error %d: %s", e.StatusCode, e.Message)
}

// NewAppError creates a new AppError instance.
func NewAppError(statusCode int, message string) *AppError {
	return &AppError{
		StatusCode: statusCode,
		Message:    message,
	}
}\n
File: ./internal/middleware/tenancy/test_helpers.go
package tenancy

import (
	"context"
)

// SetTenantID is a helper function for testing to set the tenant ID in the context
func SetTenantID(ctx context.Context, tenantID string) context.Context {
	return context.WithValue(ctx, TenantContextKey, tenantID)
}
\n
File: ./internal/middleware/tenancy/tenant.go
package tenancy

import (
	"context"
	"log"
	"net/http"
	"strings"

	"github.com/api-moose/company-earnings/internal/middleware/auth"
)

type contextKey string

const TenantContextKey contextKey = "tenantID"

type TenantMiddleware struct {
	client auth.FirebaseAuthClient
}

func NewTenantMiddleware(client auth.FirebaseAuthClient) *TenantMiddleware {
	return &TenantMiddleware{client: client}
}

// ... rest of the file remains the same

func (tm *TenantMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("Entering TenantMiddleware")

		tenantID := r.Header.Get("X-Tenant-ID")
		if tenantID == "" {
			log.Println("TenantMiddleware: Tenant ID is required")
			http.Error(w, "Tenant ID is required", http.StatusBadRequest)
			return
		}

		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			log.Println("TenantMiddleware: Missing authorization header")
			http.Error(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
			log.Println("TenantMiddleware: Invalid authorization header format")
			http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		token := parts[1]
		decodedToken, err := tm.client.VerifyIDToken(r.Context(), token)
		if err != nil {
			log.Printf("TenantMiddleware: Error verifying ID token: %v", err)
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		if decodedToken.Claims["tenantID"] != tenantID {
			log.Println("TenantMiddleware: Tenant ID mismatch")
			http.Error(w, "Tenant ID mismatch", http.StatusUnauthorized)
			return
		}

		ctx := context.WithValue(r.Context(), TenantContextKey, tenantID)
		next.ServeHTTP(w, r.WithContext(ctx))

		log.Println("Exiting TenantMiddleware")
	})
}

// GetTenantID retrieves the tenant ID from the request context
func GetTenantID(r *http.Request) (string, bool) {
	tenantID, ok := r.Context().Value(TenantContextKey).(string)
	return tenantID, ok
}
\n
File: ./internal/middleware/tenancy/tenant_test.go
package tenancy

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"firebase.google.com/go/v4/auth"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFirebaseClient struct {
	mock.Mock
}

func (m *MockFirebaseClient) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestTenantMiddleware(t *testing.T) {
	mockClient := new(MockFirebaseClient)

	validToken := &auth.Token{
		UID: "valid_user",
		Claims: map[string]interface{}{
			"tenantID": "tenant1",
		},
	}
	mockClient.On("VerifyIDToken", mock.Anything, "valid_token").Return(validToken, nil)
	mockClient.On("VerifyIDToken", mock.Anything, "invalid_token").Return(nil, assert.AnError)

	tm := NewTenantMiddleware(mockClient)

	tests := []struct {
		name           string
		token          string
		tenantID       string
		expectedStatus int
	}{
		{"Valid token and tenant ID", "Bearer valid_token", "tenant1", http.StatusOK},
		{"Missing token", "", "tenant1", http.StatusUnauthorized},
		{"Invalid token", "Bearer invalid_token", "tenant1", http.StatusUnauthorized},
		{"Tenant ID mismatch", "Bearer valid_token", "tenant2", http.StatusUnauthorized},
		{"Missing tenant ID", "Bearer valid_token", "", http.StatusBadRequest},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req, err := http.NewRequest("GET", "/", nil)
			assert.NoError(t, err)

			if tt.token != "" {
				req.Header.Set("Authorization", tt.token)
			}
			if tt.tenantID != "" {
				req.Header.Set("X-Tenant-ID", tt.tenantID)
			}

			rr := httptest.NewRecorder()
			handler := tm.Middleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				tenantID, ok := GetTenantID(r)
				assert.True(t, ok)
				assert.Equal(t, tt.tenantID, tenantID)
				w.WriteHeader(http.StatusOK)
			}))

			handler.ServeHTTP(rr, req)
			assert.Equal(t, tt.expectedStatus, rr.Code)
		})
	}

	mockClient.AssertExpectations(t)
}
\n
File: ./internal/middleware/auth/errors.go
package auth

import "errors"

var ErrInvalidToken = errors.New("invalid token")
\n
File: ./internal/middleware/auth/auth.go
package auth

import (
	"context"
	"log"
	"net/http"
	"strings"

	"firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/db/mongo"
)

type ContextKey string

const UserContextKey ContextKey = "user"

type FirebaseAuthClient interface {
	VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error)
}

type AuthMiddleware struct {
	client FirebaseAuthClient
}

func NewAuthMiddleware(client FirebaseAuthClient) *AuthMiddleware {
	return &AuthMiddleware{client: client}
}

func (am *AuthMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("Entering AuthMiddleware")
		defer log.Println("Exiting AuthMiddleware")

		authHeader := r.Header.Get("Authorization")
		log.Printf("AuthMiddleware: Authorization header: %s", authHeader)

		if authHeader == "" {
			log.Println("AuthMiddleware: Missing authorization header")
			http.Error(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
			log.Println("AuthMiddleware: Invalid authorization header format")
			http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		token := parts[1]
		log.Printf("AuthMiddleware: Extracted token: %s", token)

		decodedToken, err := am.client.VerifyIDToken(r.Context(), token)
		if err != nil {
			log.Printf("AuthMiddleware: Error verifying ID token: %v", err)
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		user := &mongo.User{
			ID: decodedToken.UID,
		}

		if email, ok := decodedToken.Claims["email"].(string); ok {
			user.Email = email
		}
		if tenantID, ok := decodedToken.Claims["tenantID"].(string); ok {
			user.TenantID = tenantID
		}
		if role, ok := decodedToken.Claims["role"].(string); ok {
			user.Role = role
		}

		log.Printf("AuthMiddleware: User authenticated: ID=%s, Email=%s, Role=%s, TenantID=%s", user.ID, user.Email, user.Role, user.TenantID)
		ctx := context.WithValue(r.Context(), UserContextKey, user)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func GetUserFromContext(r *http.Request) (*mongo.User, bool) {
	user, ok := r.Context().Value(UserContextKey).(*mongo.User)
	if !ok {
		log.Println("GetUserFromContext: User not found in context")
	} else {
		log.Printf("GetUserFromContext: User found in context: ID=%s, Email=%s, Role=%s, TenantID=%s", user.ID, user.Email, user.Role, user.TenantID)
	}
	return user, ok
}
\n
File: ./internal/middleware/auth/auth_test.go
package auth

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"firebase.google.com/go/v4/auth"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFirebaseClient struct {
	mock.Mock
}

func (m *MockFirebaseClient) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestAuthMiddleware(t *testing.T) {
	mockClient := new(MockFirebaseClient)
	validToken := &auth.Token{UID: "valid_user", Claims: map[string]interface{}{"email": "test@example.com"}}
	mockClient.On("VerifyIDToken", mock.Anything, "valid_token").Return(validToken, nil)
	mockClient.On("VerifyIDToken", mock.Anything, "invalid_token").Return(nil, assert.AnError)

	am := NewAuthMiddleware(mockClient)

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, ok := GetUserFromContext(r)
		if !ok {
			t.Error("Expected user in context, got none")
		}
		if user.Email != "test@example.com" {
			t.Errorf("Expected email 'test@example.com', got '%s'", user.Email)
		}
		w.WriteHeader(http.StatusOK)
	})

	wrappedHandler := am.Middleware(handler)

	tests := []struct {
		name           string
		token          string
		expectedStatus int
	}{
		{"Valid token", "Bearer valid_token", http.StatusOK},
		{"Missing token", "", http.StatusUnauthorized},
		{"Invalid token", "Bearer invalid_token", http.StatusUnauthorized},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/", nil)
			if tt.token != "" {
				req.Header.Add("Authorization", tt.token)
			}
			w := httptest.NewRecorder()

			wrappedHandler.ServeHTTP(w, req)

			assert.Equal(t, tt.expectedStatus, w.Code)
		})
	}

	mockClient.AssertExpectations(t)
}
\n
File: ./internal/middleware/access_control/access_control.go
package access_control

import (
	"log"
	"net/http"

	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
)

func RBACMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check if the route exists
		if !routeExists(r.URL.Path) {
			next.ServeHTTP(w, r)
			return
		}

		user, ok := auth.GetUserFromContext(r)
		if !ok {
			log.Println("RBACMiddleware: User not found in context")
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		tenantID, ok := tenancy.GetTenantID(r)
		if !ok {
			log.Println("RBACMiddleware: Tenant context not found")
			http.Error(w, "Tenant context not found", http.StatusInternalServerError)
			return
		}

		if user.Role == "" {
			log.Println("RBACMiddleware: Role not found in user record")
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		if user.TenantID != tenantID {
			log.Printf("RBACMiddleware: Tenant ID mismatch. User TenantID: %s, Request TenantID: %s", user.TenantID, tenantID)
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}

		if !isAuthorized(user.Role, r.URL.Path) {
			log.Printf("RBACMiddleware: User not authorized. Role: %s, Path: %s", user.Role, r.URL.Path)
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}

		log.Printf("RBACMiddleware: Access granted. User ID: %s, Role: %s, Path: %s", user.ID, user.Role, r.URL.Path)
		next.ServeHTTP(w, r)
	})
}

func isAuthorized(role, path string) bool {
	switch role {
	case "admin":
		return true // Admins have access to all routes
	case "user":
		return path == "/" || path == "/user" || path == "/health" || path == "/version"
	default:
		return false // Unknown roles have no access
	}
}

func routeExists(path string) bool {
	knownRoutes := []string{"/", "/admin", "/user", "/health", "/version"}
	for _, route := range knownRoutes {
		if path == route {
			return true
		}
	}
	return false
}
\n
File: ./internal/middleware/access_control/access_control_test.go
package access_control

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/api-moose/company-earnings/internal/db/mongo"
	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/go-chi/chi/v5"
	"github.com/stretchr/testify/assert"
)

func TestRBACMiddleware(t *testing.T) {
	tests := []struct {
		name           string
		user           *mongo.User
		path           string
		tenantID       string
		expectedStatus int
	}{
		{"Admin access to admin route", mongo.NewUser("1", "admin", "admin@example.com", "admin", "tenant1"), "/admin", "tenant1", http.StatusOK},
		{"Admin access to user route", mongo.NewUser("1", "admin", "admin@example.com", "admin", "tenant1"), "/user", "tenant1", http.StatusOK},
		{"User access to user route", mongo.NewUser("2", "user", "user@example.com", "user", "tenant1"), "/user", "tenant1", http.StatusOK},
		{"User access to admin route", mongo.NewUser("2", "user", "user@example.com", "user", "tenant1"), "/admin", "tenant1", http.StatusForbidden},
		{"No role", mongo.NewUser("3", "norole", "norole@example.com", "", "tenant1"), "/user", "tenant1", http.StatusUnauthorized},
		{"Invalid role", mongo.NewUser("4", "invalid", "invalid@example.com", "invalid", "tenant1"), "/user", "tenant1", http.StatusForbidden},
		{"Cross-tenant access attempt", mongo.NewUser("1", "admin", "admin@example.com", "admin", "tenant1"), "/admin", "tenant2", http.StatusForbidden},
		{"Non-existent route", mongo.NewUser("2", "user", "user@example.com", "user", "tenant1"), "/nonexistent", "tenant1", http.StatusNotFound},
		{"User access to root route", mongo.NewUser("2", "user", "user@example.com", "user", "tenant1"), "/", "tenant1", http.StatusOK},
		{"User access to health route", mongo.NewUser("2", "user", "user@example.com", "user", "tenant1"), "/health", "tenant1", http.StatusOK},
		{"User access to version route", mongo.NewUser("2", "user", "user@example.com", "user", "tenant1"), "/version", "tenant1", http.StatusOK},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := chi.NewRouter()
			r.Use(RBACMiddleware)
			r.Get("/admin", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) })
			r.Get("/user", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) })
			r.Get("/", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) })
			r.Get("/health", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) })
			r.Get("/version", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) })
			r.NotFound(func(w http.ResponseWriter, r *http.Request) {
				http.Error(w, "404 page not found", http.StatusNotFound)
			})

			req, err := http.NewRequest("GET", tt.path, nil)
			assert.NoError(t, err)

			ctx := context.WithValue(req.Context(), tenancy.TenantContextKey, tt.tenantID)
			ctx = context.WithValue(ctx, auth.UserContextKey, tt.user)
			req = req.WithContext(ctx)

			rr := httptest.NewRecorder()
			r.ServeHTTP(rr, req)

			assert.Equal(t, tt.expectedStatus, rr.Code)
		})
	}
}

func TestIsAuthorized(t *testing.T) {
	tests := []struct {
		name     string
		role     string
		path     string
		expected bool
	}{
		{"Admin access to admin route", "admin", "/admin", true},
		{"Admin access to user route", "admin", "/user", true},
		{"Admin access to root route", "admin", "/", true},
		{"Admin access to health route", "admin", "/health", true},
		{"Admin access to version route", "admin", "/version", true},
		{"Admin access to non-existent route", "admin", "/nonexistent", true},
		{"User access to user route", "user", "/user", true},
		{"User access to root route", "user", "/", true},
		{"User access to health route", "user", "/health", true},
		{"User access to version route", "user", "/version", true},
		{"User access to admin route", "user", "/admin", false},
		{"User access to non-existent route", "user", "/nonexistent", false},
		{"Invalid role access to user route", "invalid", "/user", false},
		{"Invalid role access to admin route", "invalid", "/admin", false},
		{"Invalid role access to root route", "invalid", "/", false},
		{"Invalid role access to health route", "invalid", "/health", false},
		{"Invalid role access to version route", "invalid", "/version", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isAuthorized(tt.role, tt.path)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestRouteExists(t *testing.T) {
	tests := []struct {
		name     string
		path     string
		expected bool
	}{
		{"Root route", "/", true},
		{"Admin route", "/admin", true},
		{"User route", "/user", true},
		{"Health route", "/health", true},
		{"Version route", "/version", true},
		{"Non-existent route", "/nonexistent", false},
		{"Partial match route", "/admi", false},
		{"Case-sensitive route", "/ADMIN", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := routeExists(tt.path)
			assert.Equal(t, tt.expected, result)
		})
	}
}
\n
File: ./internal/errors/dberrors/dberrors.go
package dberrors

import "fmt"

type DBError struct {
	Message string
}

func (e *DBError) Error() string {
	return fmt.Sprintf("DB Error: %s", e.Message)
}

func NewDBError(message string) *DBError {
	return &DBError{
		Message: message,
	}
}

func IsDBError(err error) bool {
	_, ok := err.(*DBError)
	return ok
}
\n
File: ./internal/errors/dberrors/dberrors_test.go
package dberrors

import (
	"errors"
	"testing"
)

func TestNewDBError(t *testing.T) {
	err := NewDBError("connection failed")
	if err.Error() != "DB Error: connection failed" {
		t.Errorf("Expected 'DB Error: connection failed', got '%s'", err.Error())
	}
}

func TestIsDBError(t *testing.T) {
	err := NewDBError("query failed")
	if !IsDBError(err) {
		t.Error("Expected IsDBError to return true")
	}

	regularErr := errors.New("regular error")
	if IsDBError(regularErr) {
		t.Error("Expected IsDBError to return false for regular error")
	}
}
\n
File: ./internal/errors/httperrors/httperrors_test.go
package httperrors

import (
	"errors"
	"net/http"
	"testing"
)

func TestNewHTTPError(t *testing.T) {
	err := NewHTTPError(http.StatusNotFound, "resource not found")
	if err.StatusCode != http.StatusNotFound {
		t.Errorf("Expected status code %d, got %d", http.StatusNotFound, err.StatusCode)
	}
	if err.Message != "resource not found" {
		t.Errorf("Expected message 'resource not found', got '%s'", err.Message)
	}
}

func TestHTTPError_Error(t *testing.T) {
	err := NewHTTPError(http.StatusBadRequest, "invalid input")
	if err.Error() != "HTTP 400: invalid input" {
		t.Errorf("Expected 'HTTP 400: invalid input', got '%s'", err.Error())
	}
}

func TestIsHTTPError(t *testing.T) {
	err := NewHTTPError(http.StatusUnauthorized, "unauthorized access")
	if !IsHTTPError(err) {
		t.Error("Expected IsHTTPError to return true")
	}

	regularErr := errors.New("regular error")
	if IsHTTPError(regularErr) {
		t.Error("Expected IsHTTPError to return false for regular error")
	}
}
\n
File: ./internal/errors/httperrors/httperrors.go
package httperrors

import (
	"fmt"
)

type HTTPError struct {
	StatusCode int
	Message    string
}

func (e *HTTPError) Error() string {
	return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}

func NewHTTPError(statusCode int, message string) *HTTPError {
	return &HTTPError{
		StatusCode: statusCode,
		Message:    message,
	}
}

func IsHTTPError(err error) bool {
	_, ok := err.(*HTTPError)
	return ok
}\n
