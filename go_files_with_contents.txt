File: ./tests/integration_test.go
package tests

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/api-moose/company-earnings/internal/config"
	"github.com/api-moose/company-earnings/internal/middleware/access_control"
	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/pocketbase/pocketbase/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockAuthApp struct {
	mock.Mock
}

func (m *MockAuthApp) FindAuthRecordByToken(token, secret string) (*models.Record, error) {
	args := m.Called(token, secret)
	if args.Get(0) != nil {
		return args.Get(0).(*models.Record), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockAuthApp) GetAuthTokenSecret() string {
	args := m.Called()
	return args.String(0)
}

func createIntegrationMockRecord() *models.Record {
	collection := &models.Collection{
		BaseModel: models.BaseModel{
			Id: "mockCollectionId",
		},
		Name: "mockCollection",
	}

	record := models.NewRecord(collection)
	record.SetId("mockId")
	record.Set("role", "admin")
	record.Set("tenantId", "test-tenant")
	return record
}

func TestMiddlewareIntegration(t *testing.T) {
	mockAuth := new(MockAuthApp)
	mockRecord := createIntegrationMockRecord()

	mockAuth.On("FindAuthRecordByToken", "valid-token", "test_secret").Return(mockRecord, nil)
	mockAuth.On("GetAuthTokenSecret").Return("test_secret")

	appConfig := &config.PocketBaseConfig{Adapter: mockAuth}

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("Success"))
	})

	// Apply middleware chain
	handlerWithMiddleware := auth.AuthMiddleware(appConfig.Adapter)(
		tenancy.TenantMiddleware(
			access_control.RBACMiddleware(handler),
		),
	)

	req := httptest.NewRequest("GET", "/", nil)
	req.Header.Set("Authorization", "Bearer valid-token")
	req.Header.Set("X-Tenant-ID", "test-tenant")
	rr := httptest.NewRecorder()

	handlerWithMiddleware.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	assert.Equal(t, "Success", rr.Body.String())
}

func TestContextPropagation(t *testing.T) {
	mockAuth := new(MockAuthApp)
	mockRecord := createIntegrationMockRecord()

	mockAuth.On("FindAuthRecordByToken", "valid-token", "test_secret").Return(mockRecord, nil)
	mockAuth.On("GetAuthTokenSecret").Return("test_secret")

	appConfig := &config.PocketBaseConfig{Adapter: mockAuth}

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, userOk := r.Context().Value("user").(*models.Record)
		tenantID, tenantOk := tenancy.GetTenantID(r)

		if !userOk || !tenantOk || user == nil || tenantID == "" {
			http.Error(w, "Context propagation failed", http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte("Context propagated successfully"))
	})

	// Apply middleware chain
	handlerWithMiddleware := auth.AuthMiddleware(appConfig.Adapter)(
		tenancy.TenantMiddleware(
			access_control.RBACMiddleware(handler),
		),
	)

	req := httptest.NewRequest("GET", "/", nil)
	req.Header.Set("Authorization", "Bearer valid-token")
	req.Header.Set("X-Tenant-ID", "test-tenant")
	rr := httptest.NewRecorder()

	handlerWithMiddleware.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	assert.Equal(t, "Context propagated successfully", rr.Body.String())
}
\n
File: ./cmd/app/main_test.go
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	firebase "firebase.google.com/go/v4"
	"firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/db/models"
	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/stretchr/testify/assert"
	"google.golang.org/api/option"
)

var authClient *auth.Client

func TestMain(m *testing.M) {
	// Initialize Firebase
	opt := option.WithCredentialsFile("path/to/serviceAccountKey.json")
	app, err := firebase.NewApp(context.Background(), nil, opt)
	if err != nil {
		log.Fatalf("error initializing app: %v", err)
	}
	authClient, err = app.Auth(context.Background())
	if err != nil {
		log.Fatalf("error getting Auth client: %v", err)
	}

	// Redirect logs to a buffer for testing
	var logBuffer bytes.Buffer
	log.SetOutput(&logBuffer)

	// Run the tests
	exitCode := m.Run()

	// Print the logs if any test failed
	if exitCode != 0 {
		fmt.Println("Test logs:")
		fmt.Println(logBuffer.String())
	}

	// Reset the log output
	log.SetOutput(os.Stderr)

	os.Exit(exitCode)
}

func setupTestRouter() http.Handler {
	return setupRouter(authClient)
}

func TestMainHandler(t *testing.T) {
	req, err := http.NewRequest("GET", "/", nil)
	assert.NoError(t, err)

	rr := httptest.NewRecorder()
	handler := setupTestRouter()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	assert.Equal(t, "Welcome to the Financial Data Platform API", rr.Body.String())
}

func TestHealthCheckHandler(t *testing.T) {
	req, err := http.NewRequest("GET", "/health", nil)
	assert.NoError(t, err)

	rr := httptest.NewRecorder()
	handler := setupTestRouter()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	assert.JSONEq(t, `{"status":"healthy"}`, strings.TrimSpace(rr.Body.String()))
}

func TestVersionHandler(t *testing.T) {
	req, err := http.NewRequest("GET", "/version", nil)
	assert.NoError(t, err)

	rr := httptest.NewRecorder()
	handler := setupTestRouter()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)

	var response map[string]string
	err = json.Unmarshal(rr.Body.Bytes(), &response)
	assert.NoError(t, err)
	assert.Contains(t, response, "version")
}

func TestSetupRouter(t *testing.T) {
	router := setupTestRouter()

	testCases := []struct {
		name           string
		path           string
		expectedStatus int
		expectedBody   string
	}{
		{"Main route", "/", http.StatusOK, "Welcome to the Financial Data Platform API"},
		{"Health check route", "/health", http.StatusOK, `{"status":"healthy"}`},
		{"Version route", "/version", http.StatusOK, `{"version":"0.1.0"}`},
		{"Nonexistent route", "/nonexistent", http.StatusNotFound, "404 page not found"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req, err := http.NewRequest("GET", tc.path, nil)
			assert.NoError(t, err)

			// Assuming you have valid tokens and tenant IDs for testing
			req.Header.Set("X-Tenant-ID", "tenant1")
			req.Header.Set("Authorization", "Bearer valid-token")

			log.Printf("TestSetupRouter: Starting test case: %s", tc.name)

			rr := httptest.NewRecorder()

			router.ServeHTTP(rr, req)

			// Use the dumpRequestResponse helper function
			dumpRequestResponse(t, req, rr)

			assert.Equal(t, tc.expectedStatus, rr.Code)
			assert.Equal(t, tc.expectedBody, strings.TrimSpace(rr.Body.String()))

			// Check if user is in context after request
			ctx := req.Context()
			userFromCtx, ok := ctx.Value(auth.UserContextKey).(*models.User)
			if ok {
				log.Printf("TestSetupRouter: User found in context after request: %+v", userFromCtx)
			} else {
				log.Println("TestSetupRouter: User not found in context after request")
			}
		})
	}
}

func TestLoggingMiddleware(t *testing.T) {
	router := setupTestRouter()

	req, err := http.NewRequest("GET", "/", nil)
	assert.NoError(t, err)

	// Assuming you have valid tokens and tenant IDs for testing
	req.Header.Set("X-Tenant-ID", "tenant1")
	req.Header.Set("Authorization", "Bearer valid-token")

	rr := httptest.NewRecorder()

	log.Println("TestLoggingMiddleware: Starting test")
	log.Printf("TestLoggingMiddleware: Request headers: %v", req.Header)

	router.ServeHTTP(rr, req)

	log.Printf("TestLoggingMiddleware: Response status: %d", rr.Code)
	log.Printf("TestLoggingMiddleware: Response body: %s", rr.Body.String())

	assert.Contains(t, rr.Body.String(), "Welcome to the Financial Data Platform API")
	assert.Equal(t, http.StatusOK, rr.Code)
}

func TestAuthMiddleware(t *testing.T) {
	router := setupTestRouter()

	testCases := []struct {
		name           string
		token          string
		expectedStatus int
	}{
		{"Valid token", "Bearer valid-token", http.StatusOK},
		{"Invalid token", "Bearer invalid-token", http.StatusUnauthorized},
		{"Missing token", "", http.StatusUnauthorized},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/", nil)
			if tc.token != "" {
				req.Header.Set("Authorization", tc.token)
			}
			req.Header.Set("X-Tenant-ID", "tenant1")

			log.Printf("TestAuthMiddleware: Starting test case: %s", tc.name)
			log.Printf("TestAuthMiddleware: Request headers: %v", req.Header)

			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			log.Printf("TestAuthMiddleware: Response status: %d", rr.Code)
			log.Printf("TestAuthMiddleware: Response body: %s", rr.Body.String())

			assert.Equal(t, tc.expectedStatus, rr.Code)

			// Check if user is in context after request
			ctx := req.Context()
			userFromCtx, ok := ctx.Value(auth.UserContextKey).(*models.User)
			if ok {
				log.Printf("TestAuthMiddleware: User found in context after request: %+v", userFromCtx)
			} else {
				log.Println("TestAuthMiddleware: User not found in context after request")
			}
		})
	}
}

func TestTenancyMiddleware(t *testing.T) {
	router := setupTestRouter()

	testCases := []struct {
		name           string
		tenantID       string
		expectedStatus int
	}{
		{"Valid tenant ID", "tenant1", http.StatusOK},
		{"Missing tenant ID", "", http.StatusBadRequest},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/", nil)
			req.Header.Set("Authorization", "Bearer valid-token")
			if tc.tenantID != "" {
				req.Header.Set("X-Tenant-ID", tc.tenantID)
			}

			log.Printf("TestTenancyMiddleware: Starting test case: %s", tc.name)
			log.Printf("TestTenancyMiddleware: Request headers: %v", req.Header)

			rr := httptest.NewRecorder()
			router.ServeHTTP(rr, req)

			log.Printf("TestTenancyMiddleware: Response status: %d", rr.Code)
			log.Printf("TestTenancyMiddleware: Response body: %s", rr.Body.String())

			assert.Equal(t, tc.expectedStatus, rr.Code)

			if tc.expectedStatus == http.StatusOK {
				tenantID, ok := tenancy.GetTenantID(req)
				assert.True(t, ok)
				assert.Equal(t, "tenant1", tenantID)
			}
		})
	}
}

// Helper function to dump request and response details
func dumpRequestResponse(t *testing.T, req *http.Request, resp *httptest.ResponseRecorder) {
	t.Logf("Request Method: %s", req.Method)
	t.Logf("Request URL: %s", req.URL.String())
	t.Logf("Request Headers: %v", req.Header)

	t.Logf("Response Status: %d", resp.Code)
	t.Logf("Response Headers: %v", resp.Header())
	t.Logf("Response Body: %s", resp.Body.String())
}
\n
File: ./cmd/app/main.go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	firebase "firebase.google.com/go/v4"
	"firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/middleware/access_control"
	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/api-moose/company-earnings/internal/utils/logging"
	"google.golang.org/api/option"
)

const version = "0.1.0"

func main() {
	opt := option.WithCredentialsFile("path/to/serviceAccountKey.json")
	app, err := firebase.NewApp(context.Background(), nil, opt)
	if err != nil {
		log.Fatalf("error initializing app: %v", err)
	}

	authClient, err := app.Auth(context.Background())
	if err != nil {
		log.Fatalf("error getting Auth client: %v", err)
	}

	router := setupRouter(authClient)

	server := &http.Server{
		Addr:    ":8080",
		Handler: router,
	}

	go func() {
		log.Println("Starting server on :8080")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Server error: %v", err)
		}
	}()

	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	<-stop

	log.Println("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server shutdown error: %v", err)
	}

	log.Println("Server stopped gracefully")
}

func setupRouter(authClient *auth.Client) http.Handler {
	mux := http.NewServeMux()
	mux.HandleFunc("/", mainHandler)
	mux.HandleFunc("/health", healthCheckHandler)
	mux.HandleFunc("/version", versionHandler)

	var handler http.Handler = mux

	handler = recoveryMiddleware(handler)
	handler = logging.LoggingMiddleware(handler)
	handler = tenancy.NewTenantMiddleware(authClient).Middleware(handler)
	handler = auth.NewAuthMiddleware(authClient).Middleware(handler)
	handler = access_control.RBACMiddleware(handler)

	log.Println("Router setup complete. Middleware chain: Recovery -> Logging -> Tenancy -> Auth -> RBAC")
	return handler
}

func mainHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.Error(w, "404 page not found", http.StatusNotFound)
		return
	}
	fmt.Fprintf(w, "Welcome to the Financial Data Platform API")
}

func healthCheckHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
}

func versionHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"version": version})
}

func recoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				log.Printf("Panic recovered: %v", err)
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			}
		}()
		next.ServeHTTP(w, r)
	})
}
\n
File: ./internal/db/seed/seed.go
\n
File: ./internal/db/repository.go
\n
File: ./internal/db/models/user_test.go
package models

import (
	"testing"
)

func TestNewUser(t *testing.T) {
	user := NewUser("1", "testuser", "test@example.com", "user", "token123", "tenant1")

	if user.ID != "1" {
		t.Errorf("Expected ID '1', got '%s'", user.ID)
	}
	if user.Username != "testuser" {
		t.Errorf("Expected Username 'testuser', got '%s'", user.Username)
	}
	if user.Email != "test@example.com" {
		t.Errorf("Expected Email 'test@example.com', got '%s'", user.Email)
	}
	if user.Role != "user" {
		t.Errorf("Expected Role 'user', got '%s'", user.Role)
	}
	if user.Token != "token123" {
		t.Errorf("Expected Token 'token123', got '%s'", user.Token)
	}
	if user.TenantID != "tenant1" {
		t.Errorf("Expected TenantID 'tenant1', got '%s'", user.TenantID)
	}
}

func TestUserValidate(t *testing.T) {
	tests := []struct {
		name    string
		user    *User
		wantErr bool
	}{
		{
			name:    "Valid user",
			user:    NewUser("1", "testuser", "test@example.com", "user", "token123", "tenant1"),
			wantErr: false,
		},
		{
			name:    "Missing ID",
			user:    NewUser("", "testuser", "test@example.com", "user", "token123", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing Username",
			user:    NewUser("1", "", "test@example.com", "user", "token123", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing Email",
			user:    NewUser("1", "testuser", "", "user", "token123", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing Role",
			user:    NewUser("1", "testuser", "test@example.com", "", "token123", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing Token",
			user:    NewUser("1", "testuser", "test@example.com", "user", "", "tenant1"),
			wantErr: true,
		},
		{
			name:    "Missing TenantID",
			user:    NewUser("1", "testuser", "test@example.com", "user", "token123", ""),
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.user.Validate()
			if (err != nil) != tt.wantErr {
				t.Errorf("User.Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
\n
File: ./internal/db/models/user.go
package models

import "errors"

// User represents a user in the system
type User struct {
	ID       string
	Username string
	Email    string
	Role     string
	Token    string
	TenantID string
}

// NewUser creates a new User instance
func NewUser(id, username, email, role, token, tenantID string) *User {
	return &User{
		ID:       id,
		Username: username,
		Email:    email,
		Role:     role,
		Token:    token,
		TenantID: tenantID,
	}
}

// Validate checks if the user data is valid
func (u *User) Validate() error {
	if u.ID == "" {
		return errors.New("id is required")
	}
	if u.Username == "" {
		return errors.New("username is required")
	}
	if u.Email == "" {
		return errors.New("email is required")
	}
	if u.Role == "" {
		return errors.New("role is required")
	}
	if u.Token == "" {
		return errors.New("token is required")
	}
	if u.TenantID == "" {
		return errors.New("tenantID is required")
	}
	return nil
}
\n
File: ./internal/db/pocketbase/pocketbase.go
\n
File: ./internal/config/config.go
package config

import (
	"context"
	"fmt"

	firebase "firebase.google.com/go"
	"google.golang.org/api/option"
)

type FirebaseApp struct {
	*firebase.App
}

func NewFirebaseApp(credentialFile string) (*FirebaseApp, error) {
	ctx := context.Background()
	opt := option.WithCredentialsFile(credentialFile)
	app, err := firebase.NewApp(ctx, nil, opt)
	if err != nil {
		return nil, fmt.Errorf("error initializing app: %v", err)
	}
	return &FirebaseApp{App: app}, nil
}
\n
File: ./internal/config/config_test.go
package config

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewFirebaseApp(t *testing.T) {
	app, err := NewFirebaseApp("path/to/serviceAccountKey.json")
	assert.NoError(t, err)
	assert.NotNil(t, app)
}
\n
File: ./internal/handlers/user/user_test.go
\n
File: ./internal/handlers/user/user.go
\n
File: ./internal/handlers/stock/stock.go
\n
File: ./internal/handlers/stock/stock_test.go
\n
File: ./internal/services/auth/auth_service_test.go
package auth

import (
	"context"
	"errors"
	"testing"

	"firebase.google.com/go/v4/auth"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFirebaseClient struct {
	mock.Mock
}

func (m *MockFirebaseClient) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockFirebaseClient) GetUser(ctx context.Context, uid string) (*auth.UserRecord, error) {
	args := m.Called(ctx, uid)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.UserRecord), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestAuthService_AuthenticateUser(t *testing.T) {
	mockClient := new(MockFirebaseClient)
	validToken := &auth.Token{UID: "valid_user"}
	userRecord := &auth.UserRecord{UserInfo: &auth.UserInfo{UID: "valid_user", Email: "test@example.com"}}

	mockClient.On("VerifyIDToken", mock.Anything, "valid_token").Return(validToken, nil)
	mockClient.On("VerifyIDToken", mock.Anything, "invalid_token").Return(nil, errors.New("invalid token"))
	mockClient.On("GetUser", mock.Anything, "valid_user").Return(userRecord, nil)

	authService := NewAuthService(mockClient)

	tests := []struct {
		name        string
		token       string
		expectedErr error
		expectedRec *auth.UserRecord
	}{
		{"Valid token", "valid_token", nil, userRecord},
		{"Invalid token", "invalid_token", errors.New("invalid token"), nil},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			record, err := authService.AuthenticateUser(context.Background(), tt.token)
			assert.Equal(t, tt.expectedErr, err)
			assert.Equal(t, tt.expectedRec, record)
		})
	}

	mockClient.AssertExpectations(t)
}
\n
File: ./internal/services/auth/auth_service.go
package auth

import (
	"context"

	"firebase.google.com/go/v4/auth"
)

type FirebaseAuthClient interface {
	VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error)
	GetUser(ctx context.Context, uid string) (*auth.UserRecord, error)
}

type AuthService struct {
	client FirebaseAuthClient
}

func NewAuthService(client FirebaseAuthClient) *AuthService {
	return &AuthService{client: client}
}

func (s *AuthService) AuthenticateUser(ctx context.Context, token string) (*auth.UserRecord, error) {
	decodedToken, err := s.client.VerifyIDToken(ctx, token)
	if err != nil {
		return nil, err
	}
	return s.client.GetUser(ctx, decodedToken.UID)
}
\n
File: ./internal/services/user/user_test.go
\n
File: ./internal/services/user/user.go
\n
File: ./internal/services/stock/stock.go
\n
File: ./internal/services/stock/stock_test.go
\n
File: ./internal/utils/utils_test.go
package main

import (
	"net/http"
	"testing"
)

func TestAppError(t *testing.T) {
	err := NewAppError(http.StatusNotFound, "Resource not found")
	if err == nil {
		t.Error("Expected error, got nil")
	}
	if err.Error() != "Error 404: Resource not found" {
		t.Errorf("Unexpected error message: got %q", err.Error())
	}
}
\n
File: ./internal/utils/response/response.go
package response

import (
	"encoding/json"
	"net/http"

	"github.com/api-moose/company-earnings/internal/errors/httperrors"
)

func JSONResponse(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(data)
}

func ErrorResponse(w http.ResponseWriter, err error) {
	httpErr, ok := err.(*httperrors.HTTPError)
	if !ok {
		httpErr = httperrors.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")
	}

	JSONResponse(w, httpErr.StatusCode, map[string]string{"error": httpErr.Message})
}
\n
File: ./internal/utils/response/response_test.go
package response

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/api-moose/company-earnings/internal/errors/httperrors"
)

func TestJSONResponse(t *testing.T) {
	w := httptest.NewRecorder()
	data := map[string]string{"message": "success"}

	JSONResponse(w, http.StatusOK, data)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status code %d, got %d", http.StatusOK, w.Code)
	}

	var response map[string]string
	err := json.Unmarshal(w.Body.Bytes(), &response)
	if err != nil {
		t.Fatalf("Error unmarshaling response: %v", err)
	}

	if response["message"] != "success" {
		t.Errorf("Expected message 'success', got '%s'", response["message"])
	}
}

func TestErrorResponse(t *testing.T) {
	w := httptest.NewRecorder()
	err := httperrors.NewHTTPError(http.StatusBadRequest, "invalid input")

	ErrorResponse(w, err)

	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected status code %d, got %d", http.StatusBadRequest, w.Code)
	}

	var response map[string]string
	jsonErr := json.Unmarshal(w.Body.Bytes(), &response)
	if jsonErr != nil {
		t.Fatalf("Error unmarshaling response: %v", jsonErr)
	}

	if response["error"] != "invalid input" {
		t.Errorf("Expected error 'invalid input', got '%s'", response["error"])
	}
}
\n
File: ./internal/utils/logging/logging.go
package logging

import (
	"log"
	"net/http"
	"time"
)

func LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("Entering LoggingMiddleware")
		start := time.Now()

		// Wrap the response writer to capture the status code
		wrappedWriter := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

		// Call the next handler
		next.ServeHTTP(wrappedWriter, r)

		// Log the request details
		log.Printf(
			"Exiting LoggingMiddleware: %s %s %s %d %v",
			r.RemoteAddr,
			r.Method,
			r.URL.Path,
			wrappedWriter.statusCode,
			time.Since(start),
		)
	})
}

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}
\n
File: ./internal/utils/logging/logging_test.go
package logging

import (
	"bytes"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestLoggingMiddleware(t *testing.T) {
	// Create a buffer to capture log output
	var buf bytes.Buffer
	log.SetOutput(&buf)

	// Create a test handler
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// Wrap the test handler with the logging middleware
	handler := LoggingMiddleware(testHandler)

	// Create a test request
	req := httptest.NewRequest("GET", "/test", nil)
	req.RemoteAddr = "127.0.0.1:12345"

	// Create a response recorder
	rr := httptest.NewRecorder()

	// Serve the request using the wrapped handler
	handler.ServeHTTP(rr, req)

	// Check if the status code is still correct
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("handler returned wrong status code: got %v want %v",
			status, http.StatusOK)
	}

	// Check if the log output contains expected information
	logOutput := buf.String()
	expectedEntries := []string{
		"127.0.0.1:12345",
		"GET",
		"/test",
		"200",
	}

	for _, entry := range expectedEntries {
		if !strings.Contains(logOutput, entry) {
			t.Errorf("Log output missing expected entry: %s", entry)
		}
	}
}
\n
File: ./internal/utils/utils.go
package main

import "fmt"

// AppError represents an application-level error.
type AppError struct {
	StatusCode int
	Message    string
}

func (e *AppError) Error() string {
	return fmt.Sprintf("Error %d: %s", e.StatusCode, e.Message)
}

// NewAppError creates a new AppError instance.
func NewAppError(statusCode int, message string) *AppError {
	return &AppError{
		StatusCode: statusCode,
		Message:    message,
	}
}\n
File: ./internal/middleware/tenancy/test_helpers.go
package tenancy

import (
	"context"
)

// SetTenantID is a helper function for testing to set the tenant ID in the context
func SetTenantID(ctx context.Context, tenantID string) context.Context {
	return context.WithValue(ctx, TenantContextKey, tenantID)
}
\n
File: ./internal/middleware/tenancy/tenant.go
package tenancy

import (
	"context"
	"log"
	"net/http"
	"strings"

	"firebase.google.com/go/v4/auth"
)

type contextKey string

const TenantContextKey contextKey = "tenantID"

// Define an interface for the Firebase Auth client
type FirebaseAuthClient interface {
	VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error)
}

type TenantMiddleware struct {
	client FirebaseAuthClient
}

func NewTenantMiddleware(client FirebaseAuthClient) *TenantMiddleware {
	return &TenantMiddleware{client: client}
}

func (tm *TenantMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("Entering TenantMiddleware")

		tenantID := r.Header.Get("X-Tenant-ID")
		if tenantID == "" {
			log.Println("TenantMiddleware: Tenant ID is required")
			http.Error(w, "Tenant ID is required", http.StatusBadRequest)
			return
		}

		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			log.Println("TenantMiddleware: Missing authorization header")
			http.Error(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
			log.Println("TenantMiddleware: Invalid authorization header format")
			http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		token := parts[1]
		decodedToken, err := tm.client.VerifyIDToken(context.Background(), token)
		if err != nil {
			log.Printf("TenantMiddleware: Error verifying ID token: %v", err)
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		if decodedToken.Claims["tenantID"] != tenantID {
			log.Println("TenantMiddleware: Tenant ID mismatch")
			http.Error(w, "Tenant ID mismatch", http.StatusUnauthorized)
			return
		}

		ctx := context.WithValue(r.Context(), TenantContextKey, tenantID)
		next.ServeHTTP(w, r.WithContext(ctx))

		log.Println("Exiting TenantMiddleware")
	})
}

// GetTenantID retrieves the tenant ID from the request context
func GetTenantID(r *http.Request) (string, bool) {
	tenantID, ok := r.Context().Value(TenantContextKey).(string)
	return tenantID, ok
}
\n
File: ./internal/middleware/tenancy/tenant_test.go
package tenancy

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"firebase.google.com/go/v4/auth"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFirebaseClient struct {
	mock.Mock
}

func (m *MockFirebaseClient) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestTenantMiddleware(t *testing.T) {
	mockClient := new(MockFirebaseClient)

	validToken := &auth.Token{
		UID: "valid_user",
		Claims: map[string]interface{}{
			"tenantID": "tenant1",
		},
	}
	mockClient.On("VerifyIDToken", mock.Anything, "valid_token").Return(validToken, nil)
	mockClient.On("VerifyIDToken", mock.Anything, "invalid_token").Return(nil, assert.AnError)

	tm := NewTenantMiddleware(mockClient)

	tests := []struct {
		name           string
		token          string
		tenantID       string
		expectedStatus int
	}{
		{"Valid token and tenant ID", "Bearer valid_token", "tenant1", http.StatusOK},
		{"Missing token", "", "tenant1", http.StatusUnauthorized},
		{"Invalid token", "Bearer invalid_token", "tenant1", http.StatusUnauthorized},
		{"Tenant ID mismatch", "Bearer valid_token", "tenant2", http.StatusUnauthorized},
		{"Missing tenant ID", "Bearer valid_token", "", http.StatusBadRequest},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req, err := http.NewRequest("GET", "/", nil)
			assert.NoError(t, err)

			if tt.token != "" {
				req.Header.Set("Authorization", tt.token)
			}
			if tt.tenantID != "" {
				req.Header.Set("X-Tenant-ID", tt.tenantID)
			}

			rr := httptest.NewRecorder()
			handler := tm.Middleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				tenantID, ok := GetTenantID(r)
				assert.True(t, ok)
				assert.Equal(t, tt.tenantID, tenantID)
				w.WriteHeader(http.StatusOK)
			}))

			handler.ServeHTTP(rr, req)
			assert.Equal(t, tt.expectedStatus, rr.Code)
		})
	}

	mockClient.AssertExpectations(t)
}
\n
File: ./internal/middleware/auth/errors.go
package auth

import "errors"

var ErrInvalidToken = errors.New("invalid token")
\n
File: ./internal/middleware/auth/auth.go
package auth

import (
	"context"
	"log"
	"net/http"
	"strings"

	"firebase.google.com/go/v4/auth"
	"github.com/api-moose/company-earnings/internal/db/models"
)

type ContextKey string

const UserContextKey ContextKey = "user"

// Define an interface for the Firebase Auth client
type FirebaseAuthClient interface {
	VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error)
}

type AuthMiddleware struct {
	client FirebaseAuthClient
}

func NewAuthMiddleware(client FirebaseAuthClient) *AuthMiddleware {
	return &AuthMiddleware{client: client}
}

func (am *AuthMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("Entering AuthMiddleware")
		defer log.Println("Exiting AuthMiddleware")

		authHeader := r.Header.Get("Authorization")
		log.Printf("AuthMiddleware: Authorization header: %s", authHeader)

		if authHeader == "" {
			log.Println("AuthMiddleware: Missing authorization header")
			http.Error(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
			log.Println("AuthMiddleware: Invalid authorization header format")
			http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		token := parts[1]
		log.Printf("AuthMiddleware: Extracted token: %s", token)

		decodedToken, err := am.client.VerifyIDToken(context.Background(), token)
		if err != nil {
			log.Printf("AuthMiddleware: Error verifying ID token: %v", err)
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		user := &models.User{
			ID:    decodedToken.UID,
			Email: decodedToken.Claims["email"].(string),
			// Populate other fields from claims as needed
		}

		log.Printf("AuthMiddleware: User authenticated: ID=%s, Email=%s", user.ID, user.Email)
		ctx := context.WithValue(r.Context(), UserContextKey, user)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func GetUserFromContext(r *http.Request) (*models.User, bool) {
	user, ok := r.Context().Value(UserContextKey).(*models.User)
	if !ok {
		log.Println("GetUserFromContext: User not found in context")
	} else {
		log.Printf("GetUserFromContext: User found in context: ID=%s, Email=%s", user.ID, user.Email)
	}
	return user, ok
}
\n
File: ./internal/middleware/auth/auth_test.go
package auth

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"firebase.google.com/go/v4/auth"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFirebaseClient struct {
	mock.Mock
}

func (m *MockFirebaseClient) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	args := m.Called(ctx, idToken)
	if args.Get(0) != nil {
		return args.Get(0).(*auth.Token), args.Error(1)
	}
	return nil, args.Error(1)
}

func TestAuthMiddleware(t *testing.T) {
	mockClient := new(MockFirebaseClient)
	validToken := &auth.Token{UID: "valid_user", Claims: map[string]interface{}{"email": "test@example.com"}}
	mockClient.On("VerifyIDToken", mock.Anything, "valid_token").Return(validToken, nil)
	mockClient.On("VerifyIDToken", mock.Anything, "invalid_token").Return(nil, assert.AnError)

	am := NewAuthMiddleware(mockClient)

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, ok := GetUserFromContext(r)
		if !ok {
			t.Error("Expected user in context, got none")
		}
		if user.Email != "test@example.com" {
			t.Errorf("Expected email 'test@example.com', got '%s'", user.Email)
		}
		w.WriteHeader(http.StatusOK)
	})

	wrappedHandler := am.Middleware(handler)

	tests := []struct {
		name           string
		token          string
		expectedStatus int
	}{
		{"Valid token", "Bearer valid_token", http.StatusOK},
		{"Missing token", "", http.StatusUnauthorized},
		{"Invalid token", "Bearer invalid_token", http.StatusUnauthorized},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req := httptest.NewRequest("GET", "/", nil)
			if tt.token != "" {
				req.Header.Add("Authorization", tt.token)
			}
			w := httptest.NewRecorder()

			wrappedHandler.ServeHTTP(w, req)

			assert.Equal(t, tt.expectedStatus, w.Code)
		})
	}

	mockClient.AssertExpectations(t)
}
\n
File: ./internal/middleware/access_control/access_control.go
package access_control

import (
	"log"
	"net/http"

	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
)

func RBACMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, ok := auth.GetUserFromContext(r)
		if !ok {
			log.Println("RBACMiddleware: User not found in context")
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		tenantID, ok := tenancy.GetTenantID(r)
		if !ok {
			log.Println("RBACMiddleware: Tenant context not found")
			http.Error(w, "Tenant context not found", http.StatusInternalServerError)
			return
		}

		if user.Role == "" {
			log.Println("RBACMiddleware: Role not found in user record")
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		if user.TenantID != tenantID {
			log.Println("RBACMiddleware: Tenant ID mismatch")
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}

		if !isAuthorized(user.Role, r.URL.Path) {
			log.Println("RBACMiddleware: User not authorized")
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func isAuthorized(role, path string) bool {
	switch role {
	case "admin":
		return true // Admins have access to all routes
	case "user":
		return path == "/user" // Users only have access to the /user route
	default:
		return false // Unknown roles have no access
	}
}
\n
File: ./internal/middleware/access_control/access_control_test.go
package access_control

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/api-moose/company-earnings/internal/db/models"
	"github.com/api-moose/company-earnings/internal/middleware/auth"
	"github.com/api-moose/company-earnings/internal/middleware/tenancy"
	"github.com/stretchr/testify/assert"
)

func TestRBACMiddleware(t *testing.T) {
	tests := []struct {
		name           string
		user           *models.User
		path           string
		tenantID       string
		expectedStatus int
	}{
		{
			name:           "Admin access to admin route",
			user:           models.NewUser("1", "admin", "admin@example.com", "admin", "admin-token", "tenant1"),
			path:           "/admin",
			tenantID:       "tenant1",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "Admin access to user route",
			user:           models.NewUser("1", "admin", "admin@example.com", "admin", "admin-token", "tenant1"),
			path:           "/user",
			tenantID:       "tenant1",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "User access to user route",
			user:           models.NewUser("2", "user", "user@example.com", "user", "user-token", "tenant1"),
			path:           "/user",
			tenantID:       "tenant1",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "User access to admin route",
			user:           models.NewUser("2", "user", "user@example.com", "user", "user-token", "tenant1"),
			path:           "/admin",
			tenantID:       "tenant1",
			expectedStatus: http.StatusForbidden,
		},
		{
			name:           "No role",
			user:           models.NewUser("3", "norole", "norole@example.com", "", "norole-token", "tenant1"),
			path:           "/user",
			tenantID:       "tenant1",
			expectedStatus: http.StatusUnauthorized,
		},
		{
			name:           "Invalid role",
			user:           models.NewUser("4", "invalid", "invalid@example.com", "invalid", "invalid-token", "tenant1"),
			path:           "/user",
			tenantID:       "tenant1",
			expectedStatus: http.StatusForbidden,
		},
		{
			name:           "Cross-tenant access attempt",
			user:           models.NewUser("1", "admin", "admin@example.com", "admin", "admin-token", "tenant1"),
			path:           "/admin",
			tenantID:       "tenant2",
			expectedStatus: http.StatusForbidden,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req, err := http.NewRequest("GET", tt.path, nil)
			assert.NoError(t, err)

			ctx := context.WithValue(req.Context(), tenancy.TenantContextKey, tt.tenantID)
			ctx = context.WithValue(ctx, auth.UserContextKey, tt.user)
			req = req.WithContext(ctx)

			rr := httptest.NewRecorder()
			handler := RBACMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusOK)
			}))

			handler.ServeHTTP(rr, req)

			assert.Equal(t, tt.expectedStatus, rr.Code)
		})
	}
}
\n
File: ./internal/errors/dberrors/dberrors.go
package dberrors

import "fmt"

type DBError struct {
	Message string
}

func (e *DBError) Error() string {
	return fmt.Sprintf("DB Error: %s", e.Message)
}

func NewDBError(message string) *DBError {
	return &DBError{
		Message: message,
	}
}

func IsDBError(err error) bool {
	_, ok := err.(*DBError)
	return ok
}
\n
File: ./internal/errors/dberrors/dberrors_test.go
package dberrors

import (
	"errors"
	"testing"
)

func TestNewDBError(t *testing.T) {
	err := NewDBError("connection failed")
	if err.Error() != "DB Error: connection failed" {
		t.Errorf("Expected 'DB Error: connection failed', got '%s'", err.Error())
	}
}

func TestIsDBError(t *testing.T) {
	err := NewDBError("query failed")
	if !IsDBError(err) {
		t.Error("Expected IsDBError to return true")
	}

	regularErr := errors.New("regular error")
	if IsDBError(regularErr) {
		t.Error("Expected IsDBError to return false for regular error")
	}
}
\n
File: ./internal/errors/httperrors/httperrors_test.go
package httperrors

import (
	"errors"
	"net/http"
	"testing"
)

func TestNewHTTPError(t *testing.T) {
	err := NewHTTPError(http.StatusNotFound, "resource not found")
	if err.StatusCode != http.StatusNotFound {
		t.Errorf("Expected status code %d, got %d", http.StatusNotFound, err.StatusCode)
	}
	if err.Message != "resource not found" {
		t.Errorf("Expected message 'resource not found', got '%s'", err.Message)
	}
}

func TestHTTPError_Error(t *testing.T) {
	err := NewHTTPError(http.StatusBadRequest, "invalid input")
	if err.Error() != "HTTP 400: invalid input" {
		t.Errorf("Expected 'HTTP 400: invalid input', got '%s'", err.Error())
	}
}

func TestIsHTTPError(t *testing.T) {
	err := NewHTTPError(http.StatusUnauthorized, "unauthorized access")
	if !IsHTTPError(err) {
		t.Error("Expected IsHTTPError to return true")
	}

	regularErr := errors.New("regular error")
	if IsHTTPError(regularErr) {
		t.Error("Expected IsHTTPError to return false for regular error")
	}
}
\n
File: ./internal/errors/httperrors/httperrors.go
package httperrors

import (
	"fmt"
)

type HTTPError struct {
	StatusCode int
	Message    string
}

func (e *HTTPError) Error() string {
	return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}

func NewHTTPError(statusCode int, message string) *HTTPError {
	return &HTTPError{
		StatusCode: statusCode,
		Message:    message,
	}
}

func IsHTTPError(err error) bool {
	_, ok := err.(*HTTPError)
	return ok
}\n
